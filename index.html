<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Document</title>
  <script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jsencrypt/3.2.1/jsencrypt.min.js"></script>
  <style></style>
</head>

<body>
  <p id="aa" style="color: #f00; display: flex;flex-wrap: wrap;"></p>
  <p class="intro2" style="display: none;" id="introtext">我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 每个人都不得不面对这些问题。 在面对这种问题时， 经过上述讨论，
    希腊说过一句富有哲理的话，最困难的事情就是认识自己。我希望诸位也能好好地体会这句话。 爱尔兰曾经说过，越是无能的人，越喜欢挑剔别人的错儿。这启发了我，
    所谓好看的皮囊千篇一律，有趣的灵魂万里挑一，关键是好看的皮囊千篇一律，有趣的灵魂万里挑一需要如何写。 俾斯麦曾经说过，失败是坚忍的最后考验。这启发了我， 在这种困难的抉择下，本人思来想去，寝食难安。
    拿破仑·希尔曾经说过，不要等待，时机永远不会恰到好处。这句话语虽然很短，但令我浮想联翩。 每个人都不得不面对这些问题。 在面对这种问题时，
    好看的皮囊千篇一律，有趣的灵魂万里挑一的发生，到底需要如何做到，不好看的皮囊千篇一律，有趣的灵魂万里挑一的发生，又会如何产生。 苏轼在不经意间这样说过，古之立大事者，不惟有超世之才，亦必有坚忍不拔之志。这不禁令我深思。
    本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。
    现在，解决好看的皮囊千篇一律，有趣的灵魂万里挑一的问题，是非常非常重要的。 所以， 冯学峰曾经提到过，当一个人用工作去迎接光明，光明很快就会来照耀着他。我希望诸位也能好好地体会这句话。 总结的来说，
    要想清楚，好看的皮囊千篇一律，有趣的灵魂万里挑一，到底是一种怎么样的存在。 一般来说。

    　　就我个人来说，好看的皮囊千篇一律，有趣的灵魂万里挑一对我的意义，不能不说非常重大。 了解清楚好看的皮囊千篇一律，有趣的灵魂万里挑一到底是一种怎么样的存在，是解决一切问题的关键。
    好看的皮囊千篇一律，有趣的灵魂万里挑一，发生了会如何，不发生又会如何。 一般来讲，我们都必须务必慎重的考虑考虑。 每个人都不得不面对这些问题。 在面对这种问题时， 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。
    生活中，若好看的皮囊千篇一律，有趣的灵魂万里挑一出现了，我们就不得不考虑它出现了的事实。 亚伯拉罕·林肯在不经意间这样说过，我这个人走得很慢，但是我从不后退。我希望诸位也能好好地体会这句话。
    好看的皮囊千篇一律，有趣的灵魂万里挑一因何而发生？ 好看的皮囊千篇一律，有趣的灵魂万里挑一，发生了会如何，不发生又会如何。 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 我们不得不面对一个非常尴尬的事实，那就是，
    好看的皮囊千篇一律，有趣的灵魂万里挑一的发生，到底需要如何做到，不好看的皮囊千篇一律，有趣的灵魂万里挑一的发生，又会如何产生。 对我个人而言，好看的皮囊千篇一律，有趣的灵魂万里挑一不仅仅是一个重大的事件，还可能会改变我的人生。
    我们都知道，只要有意义，那么就必须慎重考虑。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 好看的皮囊千篇一律，有趣的灵魂万里挑一，到底应该如何实现。
    了解清楚好看的皮囊千篇一律，有趣的灵魂万里挑一到底是一种怎么样的存在，是解决一切问题的关键。 而这些并不是完全重要，更加重要的问题是， 好看的皮囊千篇一律，有趣的灵魂万里挑一因何而发生？ 我们都知道，只要有意义，那么就必须慎重考虑。
    问题的关键究竟为何？ 我们都知道，只要有意义，那么就必须慎重考虑。 每个人都不得不面对这些问题。 在面对这种问题时， 每个人都不得不面对这些问题。 在面对这种问题时，
    带着这些问题，我们来审视一下好看的皮囊千篇一律，有趣的灵魂万里挑一。 好看的皮囊千篇一律，有趣的灵魂万里挑一，发生了会如何，不发生又会如何。
    所谓好看的皮囊千篇一律，有趣的灵魂万里挑一，关键是好看的皮囊千篇一律，有趣的灵魂万里挑一需要如何写。 了解清楚好看的皮囊千篇一律，有趣的灵魂万里挑一到底是一种怎么样的存在，是解决一切问题的关键。 每个人都不得不面对这些问题。
    在面对这种问题时， 而这些并不是完全重要，更加重要的问题是， 好看的皮囊千篇一律，有趣的灵魂万里挑一的发生，到底需要如何做到，不好看的皮囊千篇一律，有趣的灵魂万里挑一的发生，又会如何产生。
    本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 一般来说， 好看的皮囊千篇一律，有趣的灵魂万里挑一因何而发生？
    好看的皮囊千篇一律，有趣的灵魂万里挑一的发生，到底需要如何做到，不好看的皮囊千篇一律，有趣的灵魂万里挑一的发生，又会如何产生。 好看的皮囊千篇一律，有趣的灵魂万里挑一因何而发生？
    叔本华曾经提到过，意志是一个强壮的盲人，倚靠在明眼的跛子肩上。这似乎解答了我的疑惑。 吉姆·罗恩曾经提到过，要么你主宰生活，要么你被生活主宰。带着这句话，我们还要更加慎重的审视这个问题：
    本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 在这种困难的抉择下，本人思来想去，寝食难安。 我们都知道，只要有意义，那么就必须慎重考虑。 既然如此， 带着这些问题，我们来审视一下好看的皮囊千篇一律，有趣的灵魂万里挑一。
    既然如此， 就我个人来说，好看的皮囊千篇一律，有趣的灵魂万里挑一对我的意义，不能不说非常重大。 对我个人而言，好看的皮囊千篇一律，有趣的灵魂万里挑一不仅仅是一个重大的事件，还可能会改变我的人生。
    日本谚语曾经说过，不幸可能成为通向幸福的桥梁。这句话语虽然很短，但令我浮想联翩。 西班牙曾经说过，自知之明是最难得的知识。这不禁令我深思。

    　　裴斯泰洛齐说过一句富有哲理的话，今天应做的事没有做，明天再早也是耽误了。带着这句话，我们还要更加慎重的审视这个问题：
    史美尔斯说过一句富有哲理的话，书籍把我们引入最美好的社会，使我们认识各个时代的伟大智者。我希望诸位也能好好地体会这句话。 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。
    好看的皮囊千篇一律，有趣的灵魂万里挑一，发生了会如何，不发生又会如何。 所谓好看的皮囊千篇一律，有趣的灵魂万里挑一，关键是好看的皮囊千篇一律，有趣的灵魂万里挑一需要如何写。
    阿卜·日·法拉兹曾经说过，学问是异常珍贵的东西，从任何源泉吸收都不可耻。这不禁令我深思。 经过上述讨论， 那么， 既然如此， 我们都知道，只要有意义，那么就必须慎重考虑。
    苏轼曾经提到过，古之立大事者，不惟有超世之才，亦必有坚忍不拔之志。这句话语虽然很短，但令我浮想联翩。 对我个人而言，好看的皮囊千篇一律，有趣的灵魂万里挑一不仅仅是一个重大的事件，还可能会改变我的人生。 一般来说，
    对我个人而言，好看的皮囊千篇一律，有趣的灵魂万里挑一不仅仅是一个重大的事件，还可能会改变我的人生。 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。
    了解清楚好看的皮囊千篇一律，有趣的灵魂万里挑一到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。
    要想清楚，好看的皮囊千篇一律，有趣的灵魂万里挑一，到底是一种怎么样的存在。

    　　在这种困难的抉择下，本人思来想去，寝食难安。 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 罗素·贝克在不经意间这样说过，一个人即使已登上顶峰，也仍要自强不息。这启发了我，
    对我个人而言，好看的皮囊千篇一律，有趣的灵魂万里挑一不仅仅是一个重大的事件，还可能会改变我的人生。</p>
</body>


</html>

<script language="javascript">
  var index = 0;
  var word = document.getElementById("introtext").innerHTML;

  function type() {
    document.getElementById("aa").innerText = word.substring(0, index++);
  }
  setInterval(type, 100);
</script>

<script>
  /**
   *
   * 全局属性
   *
   **/

  // Infinity：属性用于存放表示正无穷大的数值
  // -Infinity：负无穷大是表示负无穷大一个数字值;
  // let x = 797693134862315e308;
  // console.log("Infinity: ", x * 1.1);
  // console.log("-Infinity: ", x * -1.1);

  // NaN 即非数值（Not a Number），NaN 属性用于引用特殊的非数字值，该属性指定的并不是不合法的数字
  // 任何数值除以0都会导致错误而终止程序执行。但是在ECMAScript中，会返回出特殊的值，因此不会影响程序的执行
  // 可以通过Number.NaN得到NaN的值，任何与NaN进行运算的结果均会为NaN,NaN与自身不相等（NaN不与任何值相等）
  // console.log(0 / 0); // NaN
  // console.log(12 / 0); //Infinity
  // console.log(NaN + 1); //NaN
  // console.log(NaN == NaN); //false
  // console.log('123'); //123

  // undefined 属性用于存放 JavaScript 中未定义的值
  // var t;
  // console.log(t); // undefined 声明了但是没有任何值

  /**
   *
   * 全局方法
   *
   **/
  // let url =
  //   "https://bonsmile.oss-cn-hangzhou.aliyuncs.com/temporary/20230208/%E7%9F%A5%E6%83%85%E5%90%8C%E6%84%8F%E4%B9%A6.pdf";
  // let originUrl =
  //   "https://bonsmile.oss-cn-hangzhou.aliyuncs.com/temporary/20230208/知情同意书.pdf";

  //  URL 只能使用 ASCII 字符集来通过因特网进行发送 为了避免服务器收到不可预知的请求，对任何用户输入的作为 URI 部分的内容你都需要用 encodeURIComponent 进行转义
  //  encodeURI() 把字符串编码为 URI。对应解码使用decodeURI()
  //  encodeURIComponent()  把字符串编码为 URI 组件。 对应解码使用encodeURIComponent() 区别就是encodeURIComponent 转义除了如下所示外的所有字符 A-Z a-z 0-9 - _ . ! ~ * ' ( )
  // let set1 = ";,/?:@&=+$"; // 保留字符
  // let set2 = "-_.!~*'()"; // 不转义字符
  // let set3 = "#"; // 数字标志
  // let set4 = "ABC abc 123"; // 字母数字字符和空格
  // console.log("encodeURI", encodeURI(set1)); // ;,/?:@&=+$
  // console.log("encodeURI", encodeURI(set2)); // -_.!~*'()
  // console.log("encodeURI", encodeURI(set3)); // #
  // console.log("encodeURI", encodeURI(set4)); // ABC%20abc%20123 (空格被编码为 %20)
  // console.log("encodeURIComponent", encodeURIComponent(set1)); // %3B%2C%2F%3F%3A%40%26%3D%2B%24
  // console.log("encodeURIComponent", encodeURIComponent(set2)); // -_.!~*'()
  // console.log("encodeURIComponent", encodeURIComponent(set3)); // %23
  // console.log("encodeURIComponent", encodeURIComponent(set4)); // ABC%20abc%20123 (空格被编码为 %20)
  // console.log(decodeURI("%3B%2C%2F%3F%3A%40%26%3D%2B%24"));
  // console.log(decodeURIComponent("ABC%20abc%20123"));

  // eval(); //函数会将传入的字符串当做 JavaScript 代码进行执行。
  // console.log(eval("2 + 2"));
  // console.log(typeof eval("2 + 2"));
  // console.log(eval("2 + 2") === eval("4"));
  // console.log("new Date(): ", eval("new Date()"));

  // isFinite() 函数用于检查其参数是否是无穷大，也可以理解为是否为一个有限数值（finite number）。如果参数是 NaN，正无穷大或者负无穷大，会返回 false，其他返回 true。
  // console.log("Infinity: ", isFinite(Infinity));//false
  // console.log("-Infinity: ", isFinite(-Infinity));//false
  // console.log("NaN: ", isFinite(NaN));//false
  // console.log("123: ", isFinite(123));//true

  // isNaN() 函数用于检查其参数是否是非数字值。如果参数值为 NaN 或字符串、对象、undefined等非数字值则返回 true, 否则返回 false。
  // https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/isNaN#%E4%BB%A4%E4%BA%BA%E8%B4%B9%E8%A7%A3%E7%9A%84%E6%80%AA%E5%BC%82%E8%A1%8C%E4%B8%BA
  console.log("isNaN(2): ", isNaN(2));
  console.log("1: ", isNaN("1")); //
  console.log("  ", isNaN("")); //
  console.log("hello ", isNaN("hello"));
  console.log("NaN ", isNaN(NaN));

  // Number()	把对象的值转换为数字。 ，Number(value) 将转换字符串或者其它值到 Number 类型。如果该值不能被转换，它会返回 NaN。
  // console.log("字符串111", Number("11")); // 11
  // console.log("Nan ，undefined", Number(NaN), Number(undefined)); //NaN NaN
  // console.log("字符串to", Number("to")); // NaN

  // parseFloat()	解析一个字符串并返回一个浮点数。
  //   如果 parseFloat 在解析过程中遇到了正号（+）、负号（- U+002D HYPHEN-MINUS）、数字（0-9）、小数点（.）、或者科学记数法中的指数（e 或 E）以外的字符，则它会忽略该字符以及之后的所有字符，返回当前已经解析到的浮点数。
  // 第二个小数点的出现也会使解析停止（在这之前的字符都会被解析）。
  // 参数首位和末位的空白符会被忽略。
  // 如果参数字符串的第一个字符不能被解析成为数字，则 parseFloat 返回 NaN。
  // parseFloat 也可以解析并返回 Infinity。
  // 返回全是3.14
  // console.log("0;: ", parseFloat("0.01e+1"));
  // console.log("parseFloat(3.14);: ", parseFloat(3.14));
  // console.log(' parseFloat("3.14");: ', parseFloat("3.14"));
  // console.log('parseFloat("  3.14  ");: ', parseFloat("  3.14  "));
  // console.log('parseFloat("314e-2");: ', parseFloat("314e-2"));
  // console.log('parseFloat("0.0314E+2");: ', parseFloat("0.0314E+2"));
  // console.log(
  //   'parseFloat("3.14some non-digit characters");: ',
  //   parseFloat("3.14some non-digit characters")
  // );

  // parseInt()	解析一个字符串并返回一个整数。parseInt(string, radix) 解析一个字符串并返回指定基数的十进制整数，radix 是 2-36 之间的整数，表示被解析字符串的基数。
  // console.log("parseInt ", parseInt("11.23", 2)); //3
  // console.log("parseInt ", parseInt(11, 2)); //3
  // console.log("parseInt ", parseInt("hh", 2));//NaN

  // String()	把对象的值转换为字符串。 String() 函数返回与字符串对象的toString()方法值一样
  // console.log(" String ", String(2)); //2
  // console.log(" String ", String(NaN)); //NaN type string
  // console.log(" String ", String("undefined")); //undefined
</script>
<script>
  // MD5: （不可逆的）是通过前台js加密的方式对密码等私密信息进行加密的方法
  // MD5加密
  // console.log(md5("123")); //202cb962ac59075b964b07152d234b70
  //  加盐：
  // console.log(md5("123" + "y")); //fe91fbaafdc24600bddedb82eede1c43

  // Base64 是一组相似的二进制到文本（binary-to-text）的编码规则，使得二进制数据在解释成 radix-64 的表现形式后能够用 ASCII 字符串的格式表示出来
  // btoa()从一个字符串或者二进制数据编码一个 Base64 字符串。
  // console.log("btoa(): ", btoa("123")); //MTIz
  // atob()解码一个 Base64 字符串。
  // console.log("atob(MTIz) ", atob("MTIz")); //123
</script>

<script>
  //  GnuPG
  // RSA加密算法是一种 非对称加密算法 ，RSA加密使用了"一对"密钥.分别是公钥和私钥,
  // ssh-keygen -t rsa 获取公钥
  // gpg --list-keys  秘钥以及有效期日期
  // gpg --export-secret-keys -o secring.gpg 获取私钥
  // gpg --keyserver hkp://keyserver.ubuntu.com --send-keys 0EC4B75E同步公钥
  // gpg -a --export 导出公钥
  // gpg -a --export-secret-keys 导出私钥
  // 公钥
  var publicKey =
    "-----BEGIN PUBLIC KEY-----MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAOu+ebw0Me7Id17/Edcc4x3U5TTx5LHDKq2KVWHPUMC3o+bIoq6xJATWB8pdwds8KH8obetTDD19m+gXxc7hcGcCAwEAAQ==-----END PUBLIC KEY-----";
  // // 私钥
  var privateKey =
    "-----BEGIN PRIVATE KEY-----MIIBVgIBADANBgkqhkiG9w0BAQEFAASCAUAwggE8AgEAAkEA6755vDQx7sh3Xv8R1xzjHdTlNPHkscMqrYpVYc9QwLej5siirrEkBNYHyl3B2zwofyht61MMPX2b6BfFzuFwZwIDAQABAkEA5Bi5ivtpsOOwdG8SIPQnYG7kk3TVVZZEDgPCF1BTjxKFCTxrdjrXvQiOD8IyVEa7toUlex4iqT6nvpJwX8CKKQIhAPjgt9q5XK5KL3ml3/kDkfiaFIK96JCFbYQtxtaONSYzAiEA8n2KDOPeNSzt3PVpvV3vrsYEOerAgPpV5B60CvuqkP0CIQDtfiuUKix6GUrij9qCGtkR3Z7TAHxMZTcT2kcTeVLYpwIhAKt4uJEq5SvHDKCt7crZzS5SmhR2ew/5dZktWPVXRyLlAiB0zvSbxHivCRYis8dMnPIcAb2f2wjfaRmiMauCYUxQbA==-----END PRIVATE KEY-----";
  // // 使用公钥加密
  var encrypt = new JSEncrypt(); // 实例化度对象
  encrypt.setPublicKey(publicKey); // 设置公钥
  var encrypted = encrypt.encrypt("博思美"); // 加密内容
  console.log(encrypted); // N0gJ9sxf1DD5D1JDoBiF0dgb+RZBrV5vB7O/0Bw+LXhwxwbUe7BOOttnzzxQsRtt+BOQiWApnxXRCJ8gWR6Q3w==
  // 私钥解密
  var decrytp = new JSEncrypt(); // 实例化对象
  decrytp.setPrivateKey(privateKey); // 设置私钥
  var uncrypted = decrytp.decrypt(encrypted); // 解密
  console.log(uncrypted); //博思美
</script>